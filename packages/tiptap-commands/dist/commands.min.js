
    /*!
    * tiptap-commands v1.14.6
    * (c) 2020 überdosis GbR (limited liability)
    * @license MIT
    */


/*!
    * tiptap-commands v1.14.6
    * (c) 2020 überdosis GbR (limited liability)
    * @license MIT
    */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("prosemirror-commands"),require("prosemirror-schema-list"),require("prosemirror-inputrules"),require("prosemirror-state"),require("prosemirror-model"),require("tiptap-utils"),require("prosemirror-utils")):"function"==typeof define&&define.amd?define(["exports","prosemirror-commands","prosemirror-schema-list","prosemirror-inputrules","prosemirror-state","prosemirror-model","tiptap-utils","prosemirror-utils"],t):t((e=e||self).tiptapCommands={},e.prosemirrorCommands,e.prosemirrorSchemaList,e.prosemirrorInputrules,e.prosemirrorState,e.prosemirrorModel,e.tiptapUtils,e.prosemirrorUtils)}(this,(function(e,t,n,r,o,i,c,s){"use strict";function u(e,t,n,r,o){if(!e.length)return!1;let i=r;return e.forEach(({cell:e,node:r,pos:o})=>{if(e)return void(i=s.setCellAttrs(e,{align:t})(i));const c={...r.attrs,align:n?t:null};i=i.setNodeMarkup(o,r.type,c,r.marks)}),o&&o(i),!0}function l(e,t){return e.type===t.nodes.bullet_list||e.type===t.nodes.ordered_list||e.type===t.nodes.todo_list}Object.defineProperty(e,"autoJoin",{enumerable:!0,get:function(){return t.autoJoin}}),Object.defineProperty(e,"baseKeymap",{enumerable:!0,get:function(){return t.baseKeymap}}),Object.defineProperty(e,"chainCommands",{enumerable:!0,get:function(){return t.chainCommands}}),Object.defineProperty(e,"createParagraphNear",{enumerable:!0,get:function(){return t.createParagraphNear}}),Object.defineProperty(e,"deleteSelection",{enumerable:!0,get:function(){return t.deleteSelection}}),Object.defineProperty(e,"exitCode",{enumerable:!0,get:function(){return t.exitCode}}),Object.defineProperty(e,"joinBackward",{enumerable:!0,get:function(){return t.joinBackward}}),Object.defineProperty(e,"joinDown",{enumerable:!0,get:function(){return t.joinDown}}),Object.defineProperty(e,"joinForward",{enumerable:!0,get:function(){return t.joinForward}}),Object.defineProperty(e,"joinUp",{enumerable:!0,get:function(){return t.joinUp}}),Object.defineProperty(e,"lift",{enumerable:!0,get:function(){return t.lift}}),Object.defineProperty(e,"liftEmptyBlock",{enumerable:!0,get:function(){return t.liftEmptyBlock}}),Object.defineProperty(e,"macBaseKeymap",{enumerable:!0,get:function(){return t.macBaseKeymap}}),Object.defineProperty(e,"newlineInCode",{enumerable:!0,get:function(){return t.newlineInCode}}),Object.defineProperty(e,"pcBaseKeymap",{enumerable:!0,get:function(){return t.pcBaseKeymap}}),Object.defineProperty(e,"selectAll",{enumerable:!0,get:function(){return t.selectAll}}),Object.defineProperty(e,"selectNodeBackward",{enumerable:!0,get:function(){return t.selectNodeBackward}}),Object.defineProperty(e,"selectNodeForward",{enumerable:!0,get:function(){return t.selectNodeForward}}),Object.defineProperty(e,"selectParentNode",{enumerable:!0,get:function(){return t.selectParentNode}}),Object.defineProperty(e,"setBlockType",{enumerable:!0,get:function(){return t.setBlockType}}),Object.defineProperty(e,"splitBlock",{enumerable:!0,get:function(){return t.splitBlock}}),Object.defineProperty(e,"splitBlockKeepMarks",{enumerable:!0,get:function(){return t.splitBlockKeepMarks}}),Object.defineProperty(e,"toggleMark",{enumerable:!0,get:function(){return t.toggleMark}}),Object.defineProperty(e,"wrapIn",{enumerable:!0,get:function(){return t.wrapIn}}),Object.defineProperty(e,"addListNodes",{enumerable:!0,get:function(){return n.addListNodes}}),Object.defineProperty(e,"liftListItem",{enumerable:!0,get:function(){return n.liftListItem}}),Object.defineProperty(e,"sinkListItem",{enumerable:!0,get:function(){return n.sinkListItem}}),Object.defineProperty(e,"splitListItem",{enumerable:!0,get:function(){return n.splitListItem}}),Object.defineProperty(e,"wrapInList",{enumerable:!0,get:function(){return n.wrapInList}}),Object.defineProperty(e,"textblockTypeInputRule",{enumerable:!0,get:function(){return r.textblockTypeInputRule}}),Object.defineProperty(e,"wrappingInputRule",{enumerable:!0,get:function(){return r.wrappingInputRule}}),e.insertText=function(e=""){return(t,n)=>{const{$from:r}=t.selection,{pos:o}=r.pos;return n(t.tr.insertText(e,o)),!0}},e.markInputRule=function(e,t,n){return new r.InputRule(e,(e,r,o,i)=>{const c=n instanceof Function?n(r):n,{tr:s}=e,u=r.length-1;let l=i,a=o;if(r[u]){const n=o+r[0].indexOf(r[u-1]),c=n+r[u-1].length-1,p=n+r[u-1].lastIndexOf(r[u]),d=p+r[u].length;if(function(e,t,n){let r=[];return n.doc.nodesBetween(e,t,(e,t)=>{r=[...r,...e.marks.map(n=>({start:t,end:t+e.nodeSize,mark:n}))]}),r}(o,i,e).filter(e=>{const{excluded:n}=e.mark.type;return n.find(e=>e.name===t.name)}).filter(e=>e.end>n).length)return!1;d<c&&s.delete(d,c),p>n&&s.delete(n,p),a=n,l=a+r[u].length}return s.addMark(a,l,t.create(c)),s.removeStoredMark(t),s})},e.markPasteRule=function(e,t,n){const r=(o,c)=>{const s=[];return o.forEach(o=>{if(o.isText){const{text:r,marks:i}=o;let u,l=0;const a=!!i.filter(e=>"link"===e.type.name)[0];for(;!a&&null!==(u=e.exec(r));)if(c&&c.type.allowsMarkType(t)&&u[1]){const e=u.index,r=e+u[0].length,i=e+u[0].indexOf(u[1]),c=i+u[1].length,a=n instanceof Function?n(u):n;e>0&&s.push(o.cut(l,e)),s.push(o.cut(i,c).mark(t.create(a).addToSet(o.marks))),l=r}l<r.length&&s.push(o.cut(l))}else s.push(o.copy(r(o.content,o)))}),i.Fragment.fromArray(s)};return new o.Plugin({props:{transformPasted:e=>new i.Slice(r(e.content),e.openStart,e.openEnd)}})},e.nodeInputRule=function(e,t,n){return new r.InputRule(e,(e,r,o,i)=>{const c=n instanceof Function?n(r):n,{tr:s}=e;return r[0]&&s.replaceWith(o-1,i,t.create(c)),s})},e.pasteRule=function(e,t,n){const r=o=>{const c=[];return o.forEach(o=>{if(o.isText){const{text:r}=o;let i,s=0;do{if(i=e.exec(r),i){const e=i.index,r=e+i[0].length,u=n instanceof Function?n(i[0]):n;e>0&&c.push(o.cut(s,e)),c.push(o.cut(e,r).mark(t.create(u).addToSet(o.marks))),s=r}}while(i);s<r.length&&c.push(o.cut(s))}else c.push(o.copy(r(o.content)))}),i.Fragment.fromArray(c)};return new o.Plugin({props:{transformPasted:e=>new i.Slice(r(e.content),e.openStart,e.openEnd)}})},e.removeMark=function(e){return(t,n)=>{const{tr:r,selection:o}=t;let{from:i,to:s}=o;const{$from:u,empty:l}=o;if(l){const t=c.getMarkRange(u,e);i=t.from,s=t.to}return r.removeMark(i,s,e),n(r)}},e.replaceText=function(e=null,t,n={}){return(r,o)=>{const{$from:i,$to:c}=r.selection,s=i.index(),u=e?e.from:i.pos,l=e?e.to:c.pos;return!!i.parent.canReplaceWith(s,s,t)&&(o&&o(r.tr.replaceWith(u,l,t.create(n))),!0)}},e.setInlineBlockType=function(e,t={}){return(n,r)=>{const{$from:o}=n.selection,i=o.index();return!!o.parent.canReplaceWith(i,i,e)&&(r&&r(n.tr.replaceSelectionWith(e.create(t))),!0)}},e.setTextAlignment=function(e,t={}){return(e,n)=>{const{doc:r,selection:o}=e;if(!o||!r)return!1;const{paragraph:i,heading:l,blockquote:a,list_item:p,table_cell:d,table_header:f}=e.schema.nodes,{ranges:m}=o;let{tr:y}=e;const g=s.isCellSelection(o),b=t.align||null;if(o.empty||1===m.length&&m[0].$from.parent.eq(m[0].$to.parent)&&!g){const{depth:e,parent:t}=o.$from,r=e>1&&c.nodeEqualsType({node:t,types:i})?[a,p,d,f]:t.type,u=e=>c.nodeEqualsType({node:e,types:r}),{pos:l,node:{type:m,attrs:g,marks:h}}=s.findParentNode(u)(o);return y=y.setNodeMarkup(l,m,{...g,align:b},h),n&&n(y),!0}const h=[];if(g){const e=[f,d];return m.forEach(t=>{const{$from:{parent:n},$to:{parent:r}}=t;if(!(n.eq(r)&&t.$from.sameParent(t.$to)&&c.nodeEqualsType({node:n,types:e})&&c.nodeEqualsType({node:r,types:e})))return;n.attrs.align!==b&&h.push({node:n,pos:t.$from.pos,cell:s.findCellClosestToPos(t.$from)});s.findChildrenByAttr(n,({align:e})=>null!=e,!0).forEach(({node:e,pos:n})=>{c.nodeEqualsType({node:e,types:[i,l,a,p]})&&h.push({node:e,pos:t.$from.pos+n})})}),u(h,b,!0,y,n)}return r.nodesBetween(o.from,o.to,(e,t)=>{if(!c.nodeEqualsType({node:e,types:[i,l,a,p]}))return!0;return(e.attrs.align||null)===b||(h.push({node:e,pos:t}),c.nodeEqualsType({node:e,types:[a,p]}))}),u(h,b,!0,y,n)}},e.splitToDefaultListItem=function(e){return function(t,n){const{$from:r,$to:o,node:c}=t.selection;if(c&&c.isBlock||r.depth<2||!r.sameParent(o))return!1;const s=r.node(-1);if(s.type!=e)return!1;if(0==r.parent.content.size){if(2==r.depth||r.node(-3).type!=e||r.index(-2)!=r.node(-2).childCount-1)return!1;if(n){let o=i.Fragment.empty;const c=r.index(-1)>0;for(let e=r.depth-(c?1:2);e>=r.depth-3;e--)o=i.Fragment.from(r.node(e).copy(o));o=o.append(i.Fragment.from(e.createAndFill()));const s=t.tr.replace(r.before(c?null:-1),r.after(-3),new i.Slice(o,c?3:2,2));s.setSelection(t.selection.constructor.near(s.doc.resolve(r.pos+(c?3:2)))),n(s.scrollIntoView())}return!0}const u=o.pos==r.end()?s.contentMatchAt(r.indexAfter(-1)).defaultType:null,l=t.tr.delete(r.pos,o.pos);let a=u&&[{type:e},{type:u}];return a||(a=[{type:e},null]),!!function(e,t,n=1,r){const o=e.resolve(t),i=o.depth-n,c=r&&r[r.length-1]||o.parent;if(i<0||o.parent.type.spec.isolating||!o.parent.canReplace(o.index(),o.parent.childCount)||!c.type.validContent(o.parent.content.cutByIndex(o.index(),o.parent.childCount)))return!1;for(let e=o.depth-1,t=n-2;e>i;e--,t--){const n=o.node(e),i=o.index(e);if(n.type.spec.isolating)return!1;let c=n.content.cutByIndex(i,n.childCount);const s=r&&r[t]||n;if(s!=n&&(c=c.replaceChild(0,s.type.create(s.attrs))),!n.canReplace(i+1,n.childCount))return!1}const s=o.indexAfter(i),u=r&&r[0];return o.node(i).canReplaceWith(s,s,u?u.type:o.node(i+1).type)}(l.doc,r.pos,2,a)&&(n&&n(l.split(r.pos,2,a).scrollIntoView()),!0)}},e.toggleBlockType=function(e,n,r={}){return(o,i,s)=>{const u=c.nodeIsActive(o,e,r),l=c.getNodeAttrs(o,e,r);return u?t.setBlockType(n,l)(o,i,s):t.setBlockType(e,l)(o,i,s)}},e.toggleList=function(e,t){return(r,o,i)=>{const{schema:c,selection:u}=r,{$from:a,$to:p}=u,d=a.blockRange(p);if(!d)return!1;const f=s.findParentNode(e=>l(e,c))(u);if(d.depth>=1&&f&&d.depth-f.depth<=1){if(f.node.type===e)return n.liftListItem(t)(r,o,i);if(l(f.node,c)&&e.validContent(f.node.content)){const{tr:t}=r;return t.setNodeMarkup(f.pos,e),o&&o(t),!1}}return n.wrapInList(e)(r,o,i)}},e.toggleWrap=function(e,n={}){return(n,r,o)=>{if(c.nodeIsActive(n,e,i))return t.lift(n,r);const i=c.getNodeAttrs(n,e);return t.wrapIn(e,i)(n,r,o)}},e.updateMark=function(e,t){return(n,r)=>{const{tr:o,selection:i,doc:s}=n;let{from:u,to:l}=i;const{$from:a,empty:p}=i;if(p){const t=c.getMarkRange(a,e);u=t.from,l=t.to}return s.rangeHasMark(u,l,e)&&o.removeMark(u,l,e),o.addMark(u,l,e.create(t)),r(o)}},Object.defineProperty(e,"__esModule",{value:!0})}));